#include "exploits.h"
#include "anti_aim.h"

#include "../../base/sdk.h"
#include "../../base/ingame objects/c_csplayer.h"
#include "../../base/ingame objects/c_basecombatweapon.h"

#include "../../base/global_variables.h"

#include "../extra/function_checks.h"
#include "../config_vars.h"

// took from weave.su and improved alot
// also added tickbase corrections
// later i will rework this, i promise.

void c_tick_base::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff)
{
	this->data.tickbase = tickbase;
	this->data.command_number = cmd;
	this->data.shift_amount = shift;
	this->data.restore_tickbase = restore;
	this->data.cmd_diff = cmd_diff;
}

void c_tick_base::fix(int new_command_number, int& tickbase)
{
	auto d = this->data;
	if (d.command_number <= 0)
		return;

	if (d.command_number == new_command_number)
		tickbase = d.tickbase - d.shift_amount + i::global_vars->sim_ticks_this_frame;

	if (d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number)
		tickbase += d.shift_amount - i::global_vars->sim_ticks_this_frame;
}

c_tick_base tick_base = {};

exploit_vars_t exploit[2] = {};

namespace exploits
{
	const int DT_SHIFT = 13;
	const int HS_SHIFT = 9;

	int shift_amount = 0;
	int shift_timer = 0;
	int charge_ticks = 0;
	int simulation_ticks = 0;

	bool need_to_recharge = false;
	bool recharge_completed = false;

	__forceinline void reset()
	{
		shift_amount = 0;
		shift_timer = 0;
		charge_ticks = 0;
	}

	void shift_cmd(c_usercmd* cmd, int amount)
	{
		int cmd_number = cmd->command_number;
		int cnt = cmd_number - 150 * ((cmd_number + 1) / 150) + 1;
		auto new_cmd = &i::input->commands[cnt];

		auto net_chan = i::client_state->net_channel_ptr;
		if (!new_cmd || !net_chan)
			return;

		std::memcpy(new_cmd, cmd, sizeof(c_usercmd));

		new_cmd->command_number = cmd->command_number + 1;
		new_cmd->buttons &= ~0x801u;

		anti_aim::fix_angle_movement(new_cmd, g::base_angle);

		for (int i = 0; i < amount; ++i)
		{
			int cmd_num = new_cmd->command_number + i;

			auto cmd_ = i::input->get_user_cmd(cmd_num);
			auto verifided_cmd = i::input->get_verified_user_cmd(cmd_num);

			std::memcpy(cmd_, new_cmd, sizeof(c_usercmd));

			cmd_->command_number = cmd_num;
			cmd_->predicted = cmd_->tickcount == INT_MAX;

			std::memcpy(verifided_cmd, cmd_, sizeof(c_usercmd));
			verifided_cmd->crc = cmd_->get_check_sum();

			++i::client_state->choked_commands;
			++net_chan->choked_packets;
			++net_chan->out_sequence_nr;
		}

	/*	if (shift_timer == 0)
			tick_base.store(g::local()->tick_base(), cmd->command_number, amount, false);*/

		*(int*)((uintptr_t)i::prediction + 0xC) = -1;
		*(int*)((uintptr_t)i::prediction + 0x1C) = 0;
	}

	void double_tap()
	{
		exploit[dt].enabled = true;

		if (exploit[dt].recharge)
		{
			exploit[dt].recharge = false;
			exploit[dt].recharging = true;
			reset();
			return;
		}

		if (exploit[dt].recharging)
		{
			shift_timer = 0;
			if (misc_checks::is_able_to_shoot(DT_SHIFT))
			{
				exploit[dt].recharging = false;
				exploit[dt].prepare = true;
				exploit[dt].bullets = 0;
			}
			else if (g::cmd->buttons & in_attack) 
				exploit[dt].bullets++;
		}

		if (!g_cfg.rage.enable)
		{
			exploit[dt].enabled = false;
			exploit[dt].prepare = false;
			reset();
			return;
		}

		if (!g_cfg.binds[dt_b].toggled || g_cfg.binds[fd_b].toggled)
		{
			exploit[dt].enabled = false;
			exploit[dt].prepare = false;

			if (!g_cfg.binds[hs_b].toggled)
			{
				if (exploit[dt].works)
				{
					shift_cmd(g::cmd, DT_SHIFT + 2);
					exploit[dt].recharge = true;
					exploit[dt].works = false;
				}
			}

			return;
		}

		if (!exploit[dt].prepare
			|| g::local()->have_immunity()
			|| g::local()->flags() & fl_frozen)
		{
			exploit[dt].enabled = false;
			if (exploit[dt].bullets == 0 && exploit[dt].works)
			{
				shift_cmd(g::cmd, DT_SHIFT + 2);
				exploit[dt].recharge = true;
				exploit[dt].works = false;
			}
			reset();
			return;
		}

		exploit[dt].works = true;

		bool can_dt = !g::weapon()->is_misc_weapon() && g::weapon()->definition_index() != weapon_revolver;
		bool is_firing = g::cmd->buttons & in_attack;

		if (recharge_completed)
		{
			if (can_dt && is_firing)
			{
				//log_console("act \n");

				shift_cmd(g::cmd, DT_SHIFT);

				exploit[dt].recharge = true;

				exploit[dt].enabled = false;
				exploit[dt].prepare = false;

				exploit[dt].bullets++;

				*g::send_packet = true;
			}
			else if (g::weapon()->definition_index() != weapon_revolver)
			{
				shift_amount = DT_SHIFT;

				//// was leaked on yougame by myself
				//// works good but needs to be improved

				//if (++shift_timer >= 14)
				//	shift_timer = 0;

				//shift_amount = shift_timer > 0 ? 14 : 0;
			}
			else
				shift_amount = shift_timer = 0;
		}
	}

	void hide_shots()
	{
		exploit[hs].shot = false;
		exploit[hs].enabled = true;

		if (!g_cfg.rage.enable || g_cfg.binds[dt_b].toggled)
		{
			exploit[hs].enabled = false;
			exploit[hs].prepare = false;
			exploit[hs].works = false;
			return;
		}

		if (!g_cfg.binds[hs_b].toggled || g_cfg.binds[fd_b].toggled)
		{
			exploit[hs].enabled = false;
			exploit[hs].prepare = false;

			if (exploit[hs].works)
			{
				shift_cmd(g::cmd, DT_SHIFT + 2);
				exploit[hs].works = false;
			}

			reset();
			return;
		}

		if (!exploit[hs].prepare
			|| g::local()->have_immunity()
			|| g::local()->flags() & fl_frozen)
		{
			exploit[hs].enabled = false;
			reset();
			return;
		}

		exploit[hs].works = true;

		if (!g::weapon()->is_misc_weapon() && g::weapon()->definition_index() != weapon_revolver)
		{
			if (misc_checks::is_able_to_shoot(HS_SHIFT) && g::cmd->buttons & in_attack)
			{
				shift_amount = HS_SHIFT;
				if (shift_amount > 0)
					tick_base.store(g::local()->tick_base(), g::cmd->command_number, simulation_ticks, true);

				*g::send_packet = true;
				exploit[hs].shot = true;
			}
			else 
				g::cmd->buttons &= ~in_attack;
		}
	}

	void prepare()
	{
		auto exp_callback = [&](const key_bind_info_t& bind_a, const key_bind_info_t& bind_b, int idx, int idx2)
		{
			if (bind_a.toggled)
			{
				if (!exploit[idx].toggle)
				{
					exploit[idx].prepare = true;
					exploit[idx].toggle = true;
				}
			}
			else
				exploit[idx].toggle = false;

			if (exploit[idx].prepare && bind_a.key != bind_b.key)
				exploit[idx2].prepare = false;
		};

		exp_callback(g_cfg.binds[dt_b], g_cfg.binds[hs_b], dt, hs);
		exp_callback(g_cfg.binds[hs_b], g_cfg.binds[dt_b], hs, dt);

		bool ready = exploit[dt].enabled && exploit[dt].prepare || exploit[hs].enabled && exploit[hs].prepare;
		if (charge_ticks < 16 && ready)
		{
			need_to_recharge = true;
			recharge_completed = false;
		}
	}

	bool enabled()
	{
		return ((g_cfg.binds[dt_b].toggled || g_cfg.binds[hs_b].toggled) && exploits::charge_ticks >= 16) && !exploits::need_to_recharge;
	}

	void run()
	{
		double_tap();
		hide_shots();
	}
}